#include <iostream>
#include <fstream>
#include <chrono>
#include <math.h>
#include <mpi.h>

#include "Problem.h"
#include "GradConj.h"
#include "BC.h"
#include "Output.h"
#include "Readfile.h"


using namespace std;



#define bloc std::cout<<"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"<<std::endl;
#define SHOW(a) std::cout << #a << std::endl;





void print_vector(std::vector<double> x)
{
  int n=x.size();
  cout<<"le vecteur de taille "<<n<<endl;

  for (int i = 0; i<n; i++)
  {
    //cout<<x[i]<<" ";
  }
  cout<<endl;
  cout<<"----------------------------------"<<endl;

}


void print_matrix(std::vector<std::vector<double>> A)
{
  //cout<<"la diagonale de la matrice:"<<endl;
  //cout<<"[ ";
  for(int i=0; i<A[0].size();i++)
  {
    //cout<<A[0][i]<<" ";
  }
  //cout<<" ]"<<endl;
  //cout<<"la sur diagonale de la matrice:"<<endl;
  //cout<<"[ ";
  for(int i=0; i<A[1].size();i++)
  {
    //cout<<A[1][i]<<" ";
  }
  //cout<<" ]"<<endl;
  //cout<<"la sur-sur diagonale de la matrice:"<<endl;
  //cout<<"[ ";
  for(int i=0; i<A[2].size();i++)
  {
    //cout<<A[2][i]<<" ";
  }
  //cout<<" ]"<<endl;
  //cout<<endl;

}


void print_matrix_verbose(std::vector<std::vector<double>> A)
{
  //cout<<"version verbose de la matrice creuse"<<endl;
  std::cout << "-------------------------------------------------" << std::endl;
  if(A.size()!=3)
  {
    //cout<<"mauvais format de matrice"<<endl;
  }else{
    //retrouvant Nx et Ny
    int Ny=A[0].size()/(A[0].size()-A[2].size());
    int Nx=A[0].size()/Ny;
    //cout<<Nx<<" "<<Ny<<endl;
    for(int i=0; i<Nx*Ny; i++)
    {
      for(int j=0; j<Nx*Ny; j++)
      {
        if(i==j)
        {
          //cout<<A[0][i]<<" ";
        }else if( (j==i+1) || (j==i-1) ){
          //cout<<A[1][i]<<" ";
        }else if(j==Nx+i){
	  // cout<<A[2][i];
        }else{
          //cout<<"0 ";
        }
      }
      //cout<<endl;
    }
  }
}

vector<int> charge (int n ,int Np, int me )
{
  int limite  =n - Np*(n/Np) ;
  vector <int > res (2) ;

 if ( me < limite)
   {
  res [0] = me*(n/Np+1);
  res [1] = res[0]+n/Np;
   }
  else
    {
      res[0]= limite*(n/Np+1)+(me-limite)*(n/Np) ;
      res[1]= res[0]+(n/Np)-1;
    }
  return res ;
}





int main(int argc, char** argv)
{

    MPI_Init(&argc,&argv);

  int me,Np,tag,input,begin,end;
  tag=100;
  std::vector<int> v(2);

  MPI_Comm_size(MPI_COMM_WORLD,&Np);
  MPI_Comm_rank(MPI_COMM_WORLD,&me);

  v=charge(Nx*Ny,Np,me);
  std::vector<std::vector>double>> C(3);
  int size=v[1]-v[0]+1;
  C[0].resize(size);
  C[1].resize(size);
  C[2].resize(size);

  std::vector<double> x(size,0.);
// initialisation de x 
for ( int i=0 ; i < size ; i++ )
{
    x[i]=1 ;
    
}
int q , r ;
q= Nx/(v[1]-v[0]) ;
r=Nx-q*(v[1]-v[0]) ;
// me va envoyer ses éléments aux procs qui en a besoin 
for (int k=1 ; k< q+2 ; k++)
{
    
        if ( me+k < Np)
            {
                break ;
            }
            MPI_Send (& x[k],size, MPI_DOUBLE , me+k,Np,MPI_COMM_WORLD ) ;
    
        if ( k==q+1)
        {   
        MPI_Send (& x[k], r , MPI_DOUBLE , me+k,Np,MPI_COMM_WORLD ) ;
        }


return 0 ;
}

